@article{hoogle_plus_2020, title={Program synthesis by type-guided abstraction
refinement}, volume={4}, DOI={10.1145/3371080}, abstractNote={We consider the
problem of type-directed component-based synthesis where, given a set of (typed)
components and a query type, the goal is to synthesize a term that inhabits the
query. Classical approaches based on proof search in intuitionistic logics do
not scale up to the standard libraries of modern languages, which span hundreds
or thousands of components. Recent graph reachability based methods proposed for
Java do scale, but only apply to monomorphic data and components: polymorphic
data and components infinitely explode the size of the graph that must be
searched, rendering synthesis intractable. We introduce type-guided abstraction
refinement (TYGAR), a new approach for scalable type-directed synthesis over
polymorphic datatypes and components. Our key insight is that we can overcome
the explosion by building a graph over abstract types which represent a
potentially unbounded set of concrete types. We show how to use graph
reachability to search for candidate terms over abstract types, and introduce a
new algorithm that uses proofs of untypeability of ill-typed candidates to
iteratively refine the abstraction until a well-typed result is found. We have
implemented TYGAR in H+, a tool that takes as input a set of Haskell libraries
and a query type, and returns a Haskell term that uses functions from the
provided libraries to implement the query type. Our support for polymorphism
allows H+ to work with higher-order functions and type classes, and enables more
precise queries due to parametricity. We have evaluated H+ on 44 queries using a
set of popular Haskell libraries with a total of 291 components. H+ returns an
interesting solution within the first five results for 32 out of 44 queries. Our
results show that TYGAR allows H+ to rapidly return well-typed terms, with the
median time to first solution of just 1.4 seconds. Moreover, we observe that
gains from iterative refinement over exhaustive enumeration are more pronounced
on harder queries.}, number={POPL}, journal={Proceedings of the ACM on
Programming Languages}, author={Guo, Zheng and James, Michael and Justo, David
and Zhou, Jiaxiao and Wang, Ziteng and Jhala, Ranjit and Polikarpova, Nadia},
year={2019}, month={Dec}, pages={12:1–12:28} }

@inproceedings{Peleg_Shoham_Yahav_2018, place={New York, NY, USA}, series={ICSE
’18}, title={Programming Not Only by Example}, ISBN={978-1-4503-5638-1},
url={http://doi.acm.org/10.1145/3180155.3180189}, DOI={10.1145/3180155.3180189},
abstractNote={Recent years have seen great progress in automated synthesis
techniques that can automatically generate code based on some intent expressed
by the programmer, but communicating this intent remains a major challenge. When
the expressed intent is coarse-grained (for example, restriction on the expected
type of an expression), the synthesizer often produces a long list of results
for the programmer to choose from, shifting the heavy-lifting to the user. An
alternative approach, successfully used in end-user synthesis, is programming by
example (PBE), where the user leverages examples to interactively and
iteratively refine the intent. However, using only examples is not expressive
enough for programmers, who can observe the generated program and refine the
intent by directly relating to parts of the generated program. We present a
novel approach to interacting with a synthesizer using a granular interaction
model. Our approach employs a rich interaction model where (i) the synthesizer
decorates a candidate program with debug information that assists in
understanding the program and identifying good or bad parts, and (ii) the user
is allowed to provide feedback not only on the expected output of a program but
also on the program itself. After identifying a program as (partially) correct
or incorrect, the user can also explicitly indicate the good or bad parts, to
allow the synthesizer to accept or discard parts of the program instead of
discarding the program as a whole. We show the value of our approach in a
controlled user study. Our study shows that participants have a strong
preference for granular feedback instead of examples and can provide granular
feedback much faster.}, note={event-place: Gothenburg, Sweden},
booktitle={Proceedings of the 40th International Conference on Software
Engineering}, publisher={ACM}, author={Peleg, Hila and Shoham, Sharon and Yahav,
Eran}, year={2018}, pages={1114–1124}, collection={ICSE ’18} }

@inproceedings{Peleg_Itzhaky_Shoham_2018, series={Lecture Notes in Computer
Science}, title={Abstraction-Based Interaction Model for Synthesis},
ISBN={978-3-319-73721-8}, abstractNote={Program synthesis is the problem of
computing from a specification a program that implements it. New and popular
variations on the synthesis problem accept specifications in formats that are
easier for the human synthesis user to provide: input-output example pairs, type
information, and partial logical specifications. These are all partial
specification formats, encoding only a fraction of the expected behavior of the
program, leaving many matching programs. This transition into partial
specification also changes the mode of work for the user, who now provides
additional specifications as long as they are unhappy with the result. This
turns synthesis into an iterative, interactive process.We present a formal model
for interactive synthesis, leveraging an abstract domain of predicates on
programs in order to describe the iterative refinement of the specifications and
reduction of the candidate program space. We use this model to describe the
behavior of several real-world synthesizers. Additionally, we present two
conditions for termination of a synthesis session, one hinging only on the
properties of the available partial specifications, and the other also on the
behavior of the user. Finally, we show conditions for realizability of the
user’s intent, and show the limitations of backtracking when it is apparent a
session will fail.}, booktitle={Verification, Model Checking, and Abstract
Interpretation}, publisher={Springer International Publishing}, author={Peleg,
Hila and Itzhaky, Shachar and Shoham, Sharon}, editor={Dillig, Isil and
Palsberg, Jens}, year={2018}, pages={382–405}, collection={Lecture Notes in
Computer Science} }

@inproceedings{Osera_Zdancewic_2015, place={New York, NY, USA}, series={PLDI
’15}, title={Type-and-example-directed Program Synthesis},
ISBN={978-1-4503-3468-6}, url={http://doi.acm.org/10.1145/2737924.2738007},
DOI={10.1145/2737924.2738007}, abstractNote={This paper presents an algorithm
for synthesizing recursive functions that process algebraic datatypes. It is
founded on proof-theoretic techniques that exploit both type information and
input–output examples to prune the search space. The algorithm uses refinement
trees, a data structure that succinctly represents constraints on the shape of
generated code. We evaluate the algorithm by using a prototype implementation to
synthesize more than 40 benchmarks and several non-trivial larger examples. Our
results demonstrate that the approach meets or outperforms the state-of-the-art
for this domain, in terms of synthesis time or attainable size of the generated
programs.}, note={event-place: Portland, OR, USA}, booktitle={Proceedings of the
36th ACM SIGPLAN Conference on Programming Language Design and Implementation},
publisher={ACM}, author={Osera, Peter-Michael and Zdancewic, Steve},
year={2015}, pages={619–630}, collection={PLDI ’15} }

@inproceedings{Feser_Chaudhuri_Dillig_2015, place={New York, NY, USA},
series={PLDI ’15}, title={Synthesizing Data Structure Transformations from
Input-output Examples}, ISBN={978-1-4503-3468-6},
url={http://doi.acm.org/10.1145/2737924.2737977}, DOI={10.1145/2737924.2737977},
abstractNote={We present a method for example-guided synthesis of functional
programs over recursive data structures. Given a set of input-output examples,
our method synthesizes a program in a functional language with higher-order
combinators like map and fold. The synthesized program is guaranteed to be the
simplest program in the language to fit the examples. Our approach combines
three technical ideas: inductive generalization, deduction, and enumerative
search. First, we generalize the input-output examples into hypotheses about the
structure of the target program. For each hypothesis, we use deduction to infer
new input/output examples for the missing subexpressions. This leads to a new
subproblem where the goal is to synthesize expressions within each hypothesis.
Since not every hypothesis can be realized into a program that fits the
examples, we use a combination of best-first enumeration and deduction to search
for a hypothesis that meets our needs. We have implemented our method in a tool
called λ2, and we evaluate this tool on a large set of synthesis problems
involving lists, trees, and nested data structures. The experiments demonstrate
the scalability and broad scope of λ2. A highlight is the synthesis of a program
believed to be the world’s earliest functional pearl.}, note={event-place:
Portland, OR, USA}, booktitle={Proceedings of the 36th ACM SIGPLAN Conference on
Programming Language Design and Implementation}, publisher={ACM}, author={Feser,
John K. and Chaudhuri, Swarat and Dillig, Isil}, year={2015}, pages={229–239},
collection={PLDI ’15} }


