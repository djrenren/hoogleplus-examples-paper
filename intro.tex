\section{Introduction}
Writing code is difficult and often inadvisable. 
%
A recent approach to this classic conundrum is \emph{program synthesis} which
takes a specification and generates a program that implements the
specification---saving us from ourselves by letting the computer do the work.
%
The specification may be a collection of input/output pairs
\cite{Feser_Chaudhuri_Dillig_2015}, a type signature \cite{hoogle_plus_2020},
or even a combination of the two \cite{Osera_Zdancewic_2015}.
%
These specifications are intentionally vague; many programs different
programs might meet the specification.
%
This keeps specification easy, but it requires the synthesizer to either guess,
or, more realistically, produce multiple candidate programs.

Sifting through a list of candidate programs can be timeconsuming, so much so
that it might be faster to write the code yourself.
%
If we could speed up this process, without requiring more input from the
user, we could allow programmers to both write easy specifications and
efficiently find their desired program.

In this work, we evaluate whether automatically generated input-output examples
for candidate programs will speed up the selection process.
%
We asked users to complete a series of synthesis tasks using a modified
version of, \hoogleplus, a program synthesizer for the Haskell
\cite{hoogle_plus_2020}, that produces input/output examples.
%
We find that while input/output examples do not appear to provide consisten
speedups, there is likely a set of circumstances where the speedup is
dramatic.