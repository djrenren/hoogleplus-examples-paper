\section{Introduction}
Writing code is difficult and often inadvisable.


A recent approach to this classic conundrum is \emph{program synthesis} which
takes a specification and generates a program that implements it---saving us
from ourselves by letting the computer do hard part.
%
A specification may be a collection of input/output pairs
\cite{Feser_Chaudhuri_Dillig_2015}, a type signature \cite{hoogle_plus_2020},
or even a combination of the two \cite{Osera_Zdancewic_2015}.
%
These specifications are intentionally vague; many different
programs might meet the same specification.
%
While this keeps specification simple, it requires the synthesizer to either guess,
or, more realistically, produce multiple candidate programs.

Sifting through a list of candidate programs can be time-consuming, so much so
that it might be faster to write the code yourself.
%
If we could speed up this process, without requiring more input from the
user, we could allow programmers to both write simple specifications and
efficiently find their desired program.

In this work, we evaluate whether automatically generated input-output examples
for candidate programs will speed up the selection process.
%
We asked users to complete a series of synthesis tasks using a modified
version of, \hoogleplus, a program synthesizer for the Haskell
\cite{hoogle_plus_2020}, that produces input/output examples.
%
We find that while input/output examples do not appear to provide consistent
speedups, there is likely a set of circumstances where the speedup is
dramatic.